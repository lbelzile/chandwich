% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/confidence_intervals.R
\name{conf_region}
\alias{conf_region}
\title{Two-dimensional confidence regions}
\usage{
conf_region(object, which_pars = NULL, range1 = c(NA, NA), range2 = c(NA,
  NA), conf = 95, mult = 2, num = c(10, 10), type = c("vertical",
  "cholesky", "dilation", "none"), ...)
}
\arguments{
\item{object}{An object of class \code{"chandwich"} returned by
\code{adjust_loglik}.}

\item{which_pars}{A vector of length 2 specifying the 2 (unfixed)
  parameters for which confidence region is required.
  Can be either a numeric vector, specifying indices of the components
  of the \strong{full} parameter vector, or a character vector of
  parameter names, which must be a subset of those supplied in
  \code{par_names} in the call to \code{\link{adjust_loglik}} that
  produced \code{object}.

  \code{which_pars} must not have any parameters in common with
  \code{attr(object, "fixed_pars")}.  \code{which_pars} must not contain
  all of the unfixed parameters, i.e. there is no point in profiling over
  all the unfixed parameters.}

\item{range1, range2}{Numeric vectors of length 2.  Respective ranges (of
the form \code{lower, upper}) of values of \code{which_pars[1]} and
\code{which_pars[2]} over which to profile.
Missing values in \code{range1} and/or \code{range2} are
filled in using \code{conf} and \code{mult}.  See below for details.}

\item{conf}{A numeric scalar. The highest confidence level of interest.
This is only relevant if \code{lower} and \code{upper} are not supplied.
In that even \code{conf} is used, in combination with \code{mult}, to
try to set up the grid of parameter values to include the largest
confidence region of interest.}

\item{mult}{A numeric vector of length 1 or the same length as
\code{which_pars}.
The search for the profile loglikelihood-based confidence limits is
conducted over the corresponding symmetric confidence intervals, extended
by a factor of the corresponding component of \code{mult}.}

\item{num}{A numeric vector of length 1 or 2.  The numbers of values at which
to evaluate the profile loglikelihood either side of the MLE.
\code{num[i]} relates to \code{which_pars[i]}.  If \code{num} has length
1 then \code{num} is replicated to have length 2.}

\item{type}{A character scalar.  The argument \code{type} to the function
returned by \code{\link{adjust_loglik}}, that is, the type of adjustment
made to the independence loglikelihood function.}

\item{...}{Further arguments to be passed to \code{\link[stats]{optim}}.
These may include \code{gr}, \code{method}, \code{lower}, \code{upper}
or \code{control}.  Any arguments that are not appropriate for
\code{\link[stats]{optim}}, i.e. not in
\code{methods::formalArgs(stats::optim)},
will be removed without warning.}

\item{lower, upper}{Numeric vectors of length 2.  For i = 1, 2:
(\code{lower[i], \code{upper[i]}}) specifies the range of values of
parameter i over which the (profile) loglikelihood is evaluated.}
}
\value{
A list with components
  \itemize{
    \item{\strong{grid1, grid2}: }{Numeric vector.   Respective values of
      \code{which_pars[1]} and \code{which_pars[2]} in the grid over which
      the (profile) loglikelihood is evaluated. }
    \item{\strong{object}: }{An object of class \code{"chandwich"}.
      The input \code{object}. }
    \item{\strong{prof_loglik}: }{An 2 \code{num} + 1 by 2 \code{num} + 1
      numeric matrix containing the values of the (profile) loglikelihood.}
    \item{\strong{type}: }{A character scalar. The input \code{type}.}
    \item{\strong{which_pars}: }{A numeric or character vector.  The input
      \code{which_pars}.  If the \code{which_pars} was numeric then
      it is supplemented by the parameter names, if these are available
      in \code{object}.}
  }
}
\description{
Calculates the (profile, if necessary) loglikelihood for a pair of
parameters from which confidence regions can be plotted using
\code{\link{plot.confreg}}.
}
\examples{
# GEV model, owtemps data ----------
# ... following Section 5.2 of Chandler and Bate (2007)

gev_loglik <- function(pars, data) {
  o_pars <- pars[c(1, 3, 5)] + pars[c(2, 4, 6)]
  w_pars <- pars[c(1, 3, 5)] - pars[c(2, 4, 6)]
  if (o_pars[2] <= 0 | w_pars[2] <= 0) return(-Inf)
  o_data <- data[, "Oxford"]
  w_data <- data[, "Worthing"]
  check <- 1 + o_pars[3] * (o_data - o_pars[1]) / o_pars[2]
  if (any(check <= 0)) return(-Inf)
  check <- 1 + w_pars[3] * (w_data - w_pars[1]) / w_pars[2]
  if (any(check <= 0)) return(-Inf)
  o_loglik <- log_gev(o_data, o_pars[1], o_pars[2], o_pars[3])
  w_loglik <- log_gev(w_data, w_pars[1], w_pars[2], w_pars[3])
  return(o_loglik + w_loglik)
}

# Initial estimates (method of moments for the Gumbel case)
sigma <- as.numeric(sqrt(6 * diag(stats::var(owtemps))) / pi)
mu <- as.numeric(colMeans(owtemps) - 0.57722 * sigma)
init <- c(mean(mu), -diff(mu) / 2, mean(sigma), -diff(sigma) / 2, 0, 0)

# Perform the log-likelihood adjustment of the full model ------

par_names <- c("mu[0]", "mu[1]", "sigma[0]", "sigma[1]", "xi[0]", "xi[1]")
large <- adjust_loglik(gev_loglik, data = owtemps, init = init,
                       par_names = par_names)

# Create a model with only 2 free parameters
fixed_pars <- c("mu[0]", "mu[1]", "sigma[1]", "xi[1]")
fixed_at <- c(attr(large, "MLE")[1], 0, 0, 0)
model2 <- adjust_loglik(larger = large, fixed_pars = fixed_pars, fixed_at = fixed_at)
pjn <- conf_region(model2, which_pars = c("sigma[0]", "xi[0]"))
plot(pjn)
\dontrun{
# Plots akin to those in Figure 4 of Chandler and Bate (2007)

which_pars <- c("mu[0]", "mu[1]")
reg_1 <- conf_region(large, which_pars = which_pars)
reg_none_1 <- conf_region(large, which_pars = which_pars, type = "none")
plot(reg_1, reg_none_1)

which_pars <- c("sigma[0]", "sigma[1]")
reg_2 <- conf_region(large, which_pars = which_pars)
reg_none_2 <- conf_region(large, which_pars = which_pars, type = "none")
plot(reg_2, reg_none_2)

which_pars <- c("sigma[0]", "xi[0]")
reg_3 <- conf_region(large, which_pars = which_pars)
reg_none_3 <- conf_region(large, which_pars = which_pars, type = "none")
plot(reg_3, reg_none_3)
}
}
